/**
 * Integration tests for F8: Card Draw Verify
 *
 * Full pipeline: ZK proof generation → on-chain verification
 * Uses the real Solidity verifier generated by snarkjs (not mock).
 */

const { expect } = require("chai");
const { ethers } = require("hardhat");
const snarkjs = require("snarkjs");
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const {
  poseidonHash,
  randomSecretKey,
  getPublicKey,
  init: initBabyJub,
} = require("../scripts/lib/circomlibBabyJub");

const CIRCUIT_NAME = "card_draw";
const BUILD_DIR = path.join(__dirname, "../circuits/build", CIRCUIT_NAME);
const WASM_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}_js`, `${CIRCUIT_NAME}.wasm`);
const ZKEY_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}.zkey`);

const N = 52;

function checkBuildFiles() {
  return fs.existsSync(ZKEY_PATH) && fs.existsSync(WASM_PATH);
}

function formatProofForSolidity(proof) {
  return {
    a: [proof.pi_a[0], proof.pi_a[1]],
    b: [
      [proof.pi_b[0][1], proof.pi_b[0][0]],
      [proof.pi_b[1][1], proof.pi_b[1][0]],
    ],
    c: [proof.pi_c[0], proof.pi_c[1]],
  };
}

/**
 * Simulate Fisher-Yates shuffle (must match circuit)
 */
async function fisherYatesShuffle(seed, n) {
  const deck = [];
  for (let i = 0; i < n; i++) deck[i] = BigInt(i);

  for (let s = 0; s < n - 1; s++) {
    const i = n - 1 - s;
    const divisor = i + 1;
    const randHash = await poseidonHash([seed, BigInt(s)]);
    const randomVal = Number(randHash & 0x3FFFn);
    const j = randomVal % divisor;
    const tmp = deck[i];
    deck[i] = deck[j];
    deck[j] = tmp;
  }

  return deck;
}

/**
 * Compute deck commitment (recursive Poseidon chain)
 */
async function computeDeckCommitment(cards, salt) {
  let h = await poseidonHash([cards[0], cards[1]]);
  for (let i = 2; i < cards.length; i++) {
    h = await poseidonHash([h, cards[i]]);
  }
  return await poseidonHash([h, salt]);
}

let _gameIdCounter = 0;

/**
 * Generate everything needed for a valid card draw
 */
async function setupCardDraw(options = {}) {
  const playerSk = options.playerSk || await randomSecretKey();
  const playerPk = await getPublicKey(playerSk);

  _gameIdCounter++;
  const gameId = options.gameId || BigInt(_gameIdCounter);
  const drawIndex = options.drawIndex !== undefined ? BigInt(options.drawIndex) : BigInt(0);
  const shuffleSeed = options.shuffleSeed || BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const handSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const deckSalt = options.deckSalt || BigInt("0x" + crypto.randomBytes(31).toString("hex"));

  // Simulate shuffle
  const deckCards = await fisherYatesShuffle(shuffleSeed, N);
  const drawnCard = deckCards[Number(drawIndex)];

  // Compute commitments
  const playerCommitment = await poseidonHash([playerPk.x, playerPk.y, gameId]);
  const deckCommitment = await computeDeckCommitment(deckCards, deckSalt);
  const drawCommitment = await poseidonHash([drawnCard, drawIndex, gameId, handSalt]);

  const circuitInputs = {
    deckCommitment: deckCommitment.toString(),
    drawCommitment: drawCommitment.toString(),
    drawIndex: drawIndex.toString(),
    gameId: gameId.toString(),
    playerCommitment: playerCommitment.toString(),
    playerPkX: playerPk.x.toString(),
    playerPkY: playerPk.y.toString(),
    playerSk: playerSk.toString(),
    shuffleSeed: shuffleSeed.toString(),
    deckCards: deckCards.map(c => c.toString()),
    drawnCard: drawnCard.toString(),
    handSalt: handSalt.toString(),
    deckSalt: deckSalt.toString(),
  };

  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    circuitInputs, WASM_PATH, ZKEY_PATH
  );

  const formattedProof = formatProofForSolidity(proof);

  return {
    circuitInputs,
    proof: formattedProof,
    publicSignals,
    deckCommitment: "0x" + deckCommitment.toString(16).padStart(64, "0"),
    drawCommitment: "0x" + drawCommitment.toString(16).padStart(64, "0"),
    drawIndex,
    gameId,
    playerCommitment: "0x" + playerCommitment.toString(16).padStart(64, "0"),
    playerSk,
    shuffleSeed,
    deckSalt,
    deckCards,
  };
}

describe("F8: Card Draw - Integration", function () {
  this.timeout(600000); // 10 min - shuffle proofs are slow

  let cardDraw;
  let hasBuild;

  before(async function () {
    await initBabyJub();
    hasBuild = checkBuildFiles();
    if (!hasBuild) {
      console.log("\n  ⚠️  Skipping integration tests: circuit not fully compiled");
      console.log("     Run: node scripts/compile-circuit.js card_draw\n");
      this.skip();
    }

    const verifierPath = path.join(__dirname, "../contracts/verifiers/CardDrawVerifier.sol");
    if (!fs.existsSync(verifierPath)) {
      console.log("\n  ⚠️  Skipping: Solidity verifier not generated yet");
      this.skip();
    }
  });

  beforeEach(async function () {
    if (!hasBuild) this.skip();

    let verifierAddress;
    try {
      const Verifier = await ethers.getContractFactory("contracts/verifiers/CardDrawVerifier.sol:Groth16Verifier");
      const verifier = await Verifier.deploy();
      verifierAddress = await verifier.getAddress();
    } catch (e) {
      const MockVerifier = await ethers.getContractFactory("MockCardDrawVerifier");
      const mockVerifier = await MockVerifier.deploy();
      verifierAddress = await mockVerifier.getAddress();
    }

    const CardDraw = await ethers.getContractFactory("CardDraw");
    cardDraw = await CardDraw.deploy(verifierAddress);
  });

  describe("Full pipeline: proof generation → on-chain verification", function () {
    it("should register deck and draw card with real ZK proof", async function () {
      const tx = await setupCardDraw();

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("encrypted-deck")
      );

      expect(await cardDraw.getNoteState(tx.deckCommitment)).to.equal(1);

      await cardDraw.drawCard(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.deckCommitment, tx.drawCommitment,
        tx.drawIndex, tx.gameId, tx.playerCommitment,
        ethers.toUtf8Bytes("encrypted-card")
      );

      // Deck still valid (persistent)
      expect(await cardDraw.getNoteState(tx.deckCommitment)).to.equal(1);
      // Draw note created
      expect(await cardDraw.getNoteState(tx.drawCommitment)).to.equal(1);
      // Draw index marked
      expect(await cardDraw.drawnCards(tx.gameId, tx.drawIndex)).to.be.true;
    });

    it("should draw at different index", async function () {
      const tx = await setupCardDraw({ drawIndex: 10 });

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("encrypted")
      );

      await cardDraw.drawCard(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.deckCommitment, tx.drawCommitment,
        tx.drawIndex, tx.gameId, tx.playerCommitment,
        ethers.toUtf8Bytes("card-enc")
      );

      expect(await cardDraw.getNoteState(tx.drawCommitment)).to.equal(1);
      expect(await cardDraw.drawnCards(tx.gameId, tx.drawIndex)).to.be.true;
    });

    it("should allow multiple draws from same deck", async function () {
      const playerSk = await randomSecretKey();
      const shuffleSeed = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
      const deckSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
      const gameId = BigInt(100);

      // First draw at index 0
      const tx1 = await setupCardDraw({ playerSk, shuffleSeed, deckSalt, gameId, drawIndex: 0 });

      await cardDraw.registerDeck(
        tx1.deckCommitment, tx1.gameId,
        ethers.toUtf8Bytes("enc")
      );

      await cardDraw.drawCard(
        tx1.proof.a, tx1.proof.b, tx1.proof.c,
        tx1.deckCommitment, tx1.drawCommitment,
        tx1.drawIndex, tx1.gameId, tx1.playerCommitment,
        ethers.toUtf8Bytes("card-0")
      );

      // Second draw at index 1 (same deck, same deckSalt → same commitment)
      const tx2 = await setupCardDraw({ playerSk, shuffleSeed, deckSalt, gameId, drawIndex: 1 });

      await cardDraw.drawCard(
        tx2.proof.a, tx2.proof.b, tx2.proof.c,
        tx2.deckCommitment, tx2.drawCommitment,
        tx2.drawIndex, tx2.gameId, tx2.playerCommitment,
        ethers.toUtf8Bytes("card-1")
      );

      // Both drawn
      expect(await cardDraw.drawnCards(tx1.gameId, 0)).to.be.true;
      expect(await cardDraw.drawnCards(tx1.gameId, 1)).to.be.true;
      // Deck still valid
      expect(await cardDraw.getNoteState(tx1.deckCommitment)).to.equal(1);
    });
  });

  describe("Security: rejection cases", function () {
    it("should reject duplicate drawIndex", async function () {
      const tx = await setupCardDraw();

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("enc")
      );

      await cardDraw.drawCard(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.deckCommitment, tx.drawCommitment,
        tx.drawIndex, tx.gameId, tx.playerCommitment,
        ethers.toUtf8Bytes("enc")
      );

      const fakeDraw = ethers.keccak256(ethers.toUtf8Bytes("fake-draw"));
      await expect(
        cardDraw.drawCard(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.deckCommitment, fakeDraw,
          tx.drawIndex, tx.gameId, tx.playerCommitment,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Card already drawn at this index");
    });

    it("should reject duplicate deck registration", async function () {
      const tx = await setupCardDraw();

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("enc")
      );

      const fakeDeck = ethers.keccak256(ethers.toUtf8Bytes("diff-deck"));
      await expect(
        cardDraw.registerDeck(fakeDeck, tx.gameId, ethers.toUtf8Bytes("enc"))
      ).to.be.revertedWith("Deck already registered for this game");
    });

    it("should reject duplicate note hash registration", async function () {
      const tx = await setupCardDraw();

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        cardDraw.registerDeck(tx.deckCommitment, 999, ethers.toUtf8Bytes("enc"))
      ).to.be.revertedWith("Note already exists");
    });
  });

  describe("Events", function () {
    it("should emit DeckRegistered event", async function () {
      const tx = await setupCardDraw();

      await expect(
        cardDraw.registerDeck(
          tx.deckCommitment, tx.gameId,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(cardDraw, "DeckRegistered");
    });

    it("should emit CardDrawn event on draw", async function () {
      const tx = await setupCardDraw();

      await cardDraw.registerDeck(
        tx.deckCommitment, tx.gameId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        cardDraw.drawCard(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.deckCommitment, tx.drawCommitment,
          tx.drawIndex, tx.gameId, tx.playerCommitment,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(cardDraw, "CardDrawn");
    });
  });
});
