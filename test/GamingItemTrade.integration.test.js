/**
 * Integration tests for F5: Gaming Item Trade
 *
 * Full pipeline: ZK proof generation → on-chain verification
 * Uses the real Solidity verifier generated by snarkjs (not mock).
 */

const { expect } = require("chai");
const { ethers } = require("hardhat");
const snarkjs = require("snarkjs");
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const {
  poseidonHash,
  randomSecretKey,
  getPublicKey,
  init: initBabyJub,
} = require("../scripts/lib/circomlibBabyJub");

const CIRCUIT_NAME = "gaming_item_trade";
const BUILD_DIR = path.join(__dirname, "../circuits/build", CIRCUIT_NAME);
const WASM_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}_js`, `${CIRCUIT_NAME}.wasm`);
const ZKEY_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}.zkey`);

function checkBuildFiles() {
  return fs.existsSync(ZKEY_PATH) && fs.existsSync(WASM_PATH);
}

function formatProofForSolidity(proof) {
  return {
    a: [proof.pi_a[0], proof.pi_a[1]],
    b: [
      [proof.pi_b[0][1], proof.pi_b[0][0]],
      [proof.pi_b[1][1], proof.pi_b[1][0]],
    ],
    c: [proof.pi_c[0], proof.pi_c[1]],
  };
}

let _itemIdCounter = 0;

/**
 * Generate everything needed for a valid item trade
 */
async function setupTrade(options = {}) {
  const sellerSk = options.sellerSk || await randomSecretKey();
  const sellerPk = await getPublicKey(sellerSk);

  const buyerSk = options.buyerSk || await randomSecretKey();
  const buyerPk = await getPublicKey(buyerSk);

  _itemIdCounter++;
  const itemId = options.itemId || BigInt(_itemIdCounter);
  const itemType = options.itemType || BigInt(3);
  const itemAttributes = options.itemAttributes || BigInt(9999);
  const gameId = options.gameId || BigInt(42);
  const price = options.price !== undefined ? BigInt(options.price) : BigInt(1000);
  const paymentToken = options.paymentToken || BigInt(1);
  const oldSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const newSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const paymentSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));

  const oldItemHash = await poseidonHash([
    sellerPk.x, sellerPk.y, itemId, itemType, itemAttributes, gameId, oldSalt,
  ]);
  const newItemHash = await poseidonHash([
    buyerPk.x, buyerPk.y, itemId, itemType, itemAttributes, gameId, newSalt,
  ]);
  const nullifier = await poseidonHash([itemId, oldSalt, sellerSk]);

  let paymentNoteHash;
  if (price === 0n) {
    paymentNoteHash = 0n;
  } else {
    paymentNoteHash = await poseidonHash([
      sellerPk.x, sellerPk.y, price, paymentToken, paymentSalt,
    ]);
  }

  const circuitInputs = {
    oldItemHash: oldItemHash.toString(),
    newItemHash: newItemHash.toString(),
    paymentNoteHash: paymentNoteHash.toString(),
    gameId: gameId.toString(),
    nullifier: nullifier.toString(),
    sellerPkX: sellerPk.x.toString(),
    sellerPkY: sellerPk.y.toString(),
    sellerSk: sellerSk.toString(),
    oldSalt: oldSalt.toString(),
    buyerPkX: buyerPk.x.toString(),
    buyerPkY: buyerPk.y.toString(),
    newSalt: newSalt.toString(),
    itemId: itemId.toString(),
    itemType: itemType.toString(),
    itemAttributes: itemAttributes.toString(),
    price: price.toString(),
    paymentToken: paymentToken.toString(),
    paymentSalt: paymentSalt.toString(),
  };

  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    circuitInputs, WASM_PATH, ZKEY_PATH
  );

  const formattedProof = formatProofForSolidity(proof);

  return {
    circuitInputs,
    proof: formattedProof,
    publicSignals,
    oldItemHash: "0x" + oldItemHash.toString(16).padStart(64, "0"),
    newItemHash: "0x" + newItemHash.toString(16).padStart(64, "0"),
    paymentNoteHash: "0x" + paymentNoteHash.toString(16).padStart(64, "0"),
    gameId,
    itemId,
    nullifier: "0x" + nullifier.toString(16).padStart(64, "0"),
    sellerSk,
    buyerSk,
    // Keep these for chained trades
    itemType,
    itemAttributes,
    price,
    paymentToken,
  };
}

describe("F5: Gaming Item Trade - Integration", function () {
  this.timeout(300000);

  let gamingItemTrade;
  let hasBuild;

  before(async function () {
    await initBabyJub();
    hasBuild = checkBuildFiles();
    if (!hasBuild) {
      console.log("\n  ⚠️  Skipping integration tests: circuit not fully compiled");
      console.log("     Run: node scripts/compile-circuit.js gaming_item_trade\n");
      this.skip();
    }

    const verifierPath = path.join(__dirname, "../contracts/verifiers/GamingItemTradeVerifier.sol");
    if (!fs.existsSync(verifierPath)) {
      console.log("\n  ⚠️  Skipping: Solidity verifier not generated yet");
      this.skip();
    }
  });

  beforeEach(async function () {
    if (!hasBuild) this.skip();

    let verifierAddress;
    try {
      // The snarkjs-generated verifier contract name is "Groth16Verifier"
      // but we may have multiple. Try the gaming item trade specific one.
      const Verifier = await ethers.getContractFactory("contracts/verifiers/GamingItemTradeVerifier.sol:Groth16Verifier");
      const verifier = await Verifier.deploy();
      verifierAddress = await verifier.getAddress();
    } catch (e) {
      // Fallback to mock if verifier not compiled
      const MockVerifier = await ethers.getContractFactory("MockGamingItemTradeVerifier");
      const mockVerifier = await MockVerifier.deploy();
      verifierAddress = await mockVerifier.getAddress();
    }

    const GamingItemTrade = await ethers.getContractFactory("GamingItemTrade");
    gamingItemTrade = await GamingItemTrade.deploy(verifierAddress);
  });

  describe("Full pipeline: proof generation → on-chain verification", function () {
    it("should register and trade item with real ZK proof (paid)", async function () {
      const tx = await setupTrade({ price: 1000 });

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("encrypted")
      );

      expect(await gamingItemTrade.getNoteState(tx.oldItemHash)).to.equal(1);

      await gamingItemTrade.tradeItem(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.oldItemHash, tx.newItemHash, tx.paymentNoteHash,
        tx.gameId, tx.nullifier,
        ethers.toUtf8Bytes("new-encrypted")
      );

      expect(await gamingItemTrade.getNoteState(tx.oldItemHash)).to.equal(2);
      expect(await gamingItemTrade.getNoteState(tx.newItemHash)).to.equal(1);
      expect(await gamingItemTrade.isNullifierUsed(tx.nullifier)).to.be.true;
    });

    it("should register and trade item as gift (price=0)", async function () {
      const tx = await setupTrade({ price: 0 });

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("encrypted")
      );

      await gamingItemTrade.tradeItem(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.oldItemHash, tx.newItemHash, tx.paymentNoteHash,
        tx.gameId, tx.nullifier,
        ethers.toUtf8Bytes("new-encrypted")
      );

      expect(await gamingItemTrade.getNoteState(tx.oldItemHash)).to.equal(2);
      expect(await gamingItemTrade.getNoteState(tx.newItemHash)).to.equal(1);
    });

    it("should allow chained trades (A → B → C)", async function () {
      // First trade: A → B
      const tx1 = await setupTrade();

      await gamingItemTrade.registerItem(
        tx1.oldItemHash, tx1.gameId, tx1.itemId,
        ethers.toUtf8Bytes("enc")
      );

      await gamingItemTrade.tradeItem(
        tx1.proof.a, tx1.proof.b, tx1.proof.c,
        tx1.oldItemHash, tx1.newItemHash, tx1.paymentNoteHash,
        tx1.gameId, tx1.nullifier,
        ethers.toUtf8Bytes("enc-b")
      );

      // Second trade: B → C
      const ownerCSk = await randomSecretKey();
      const ownerCPk = await getPublicKey(ownerCSk);
      const ownerBPk = await getPublicKey(tx1.buyerSk);
      const newSalt2 = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
      const paymentSalt2 = BigInt("0x" + crypto.randomBytes(31).toString("hex"));

      const bSalt = BigInt(tx1.circuitInputs.newSalt);
      const itemId = tx1.itemId;
      const itemType = tx1.itemType;
      const itemAttributes = tx1.itemAttributes;
      const gameId = tx1.gameId;
      const price2 = BigInt(500);
      const paymentToken2 = BigInt(1);

      const newItemHash2 = await poseidonHash([
        ownerCPk.x, ownerCPk.y, itemId, itemType, itemAttributes, gameId, newSalt2,
      ]);
      const nullifier2 = await poseidonHash([itemId, bSalt, tx1.buyerSk]);
      const paymentNoteHash2 = await poseidonHash([
        ownerBPk.x, ownerBPk.y, price2, paymentToken2, paymentSalt2,
      ]);

      const circuitInputs2 = {
        oldItemHash: tx1.circuitInputs.newItemHash,
        newItemHash: newItemHash2.toString(),
        paymentNoteHash: paymentNoteHash2.toString(),
        gameId: gameId.toString(),
        nullifier: nullifier2.toString(),
        sellerPkX: ownerBPk.x.toString(),
        sellerPkY: ownerBPk.y.toString(),
        sellerSk: tx1.buyerSk.toString(),
        oldSalt: bSalt.toString(),
        buyerPkX: ownerCPk.x.toString(),
        buyerPkY: ownerCPk.y.toString(),
        newSalt: newSalt2.toString(),
        itemId: itemId.toString(),
        itemType: itemType.toString(),
        itemAttributes: itemAttributes.toString(),
        price: price2.toString(),
        paymentToken: paymentToken2.toString(),
        paymentSalt: paymentSalt2.toString(),
      };

      const { proof: proof2 } = await snarkjs.groth16.fullProve(
        circuitInputs2, WASM_PATH, ZKEY_PATH
      );
      const fp2 = formatProofForSolidity(proof2);

      const newItemHash2Hex = "0x" + newItemHash2.toString(16).padStart(64, "0");
      const nullifier2Hex = "0x" + nullifier2.toString(16).padStart(64, "0");
      const paymentNoteHash2Hex = "0x" + paymentNoteHash2.toString(16).padStart(64, "0");

      await gamingItemTrade.tradeItem(
        fp2.a, fp2.b, fp2.c,
        tx1.newItemHash, newItemHash2Hex, paymentNoteHash2Hex,
        gameId, nullifier2Hex,
        ethers.toUtf8Bytes("enc-c")
      );

      expect(await gamingItemTrade.getNoteState(tx1.newItemHash)).to.equal(2);
      expect(await gamingItemTrade.getNoteState(newItemHash2Hex)).to.equal(1);
    });
  });

  describe("Security: rejection cases", function () {
    it("should reject double-spend (same nullifier)", async function () {
      const tx = await setupTrade();

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("enc")
      );

      await gamingItemTrade.tradeItem(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.oldItemHash, tx.newItemHash, tx.paymentNoteHash,
        tx.gameId, tx.nullifier,
        ethers.toUtf8Bytes("enc")
      );

      const fakeNewHash = ethers.keccak256(ethers.toUtf8Bytes("fake-new"));
      await expect(
        gamingItemTrade.tradeItem(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.newItemHash, fakeNewHash, tx.paymentNoteHash,
          tx.gameId, tx.nullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Nullifier already used");
    });

    it("should reject trade of already-spent note", async function () {
      const tx = await setupTrade();

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("enc")
      );

      await gamingItemTrade.tradeItem(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.oldItemHash, tx.newItemHash, tx.paymentNoteHash,
        tx.gameId, tx.nullifier,
        ethers.toUtf8Bytes("enc")
      );

      const fakeNullifier = ethers.keccak256(ethers.toUtf8Bytes("fake-null"));
      const fakeNewHash = ethers.keccak256(ethers.toUtf8Bytes("fake-new2"));
      await expect(
        gamingItemTrade.tradeItem(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.oldItemHash, fakeNewHash, tx.paymentNoteHash,
          tx.gameId, fakeNullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Note does not exist or already spent");
    });

    it("should reject duplicate item registration", async function () {
      const tx = await setupTrade();

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("enc")
      );

      const fakeHash = ethers.keccak256(ethers.toUtf8Bytes("different-hash"));
      await expect(
        gamingItemTrade.registerItem(
          fakeHash, tx.gameId, tx.itemId,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Item already registered");
    });

    it("should reject duplicate note hash registration", async function () {
      const tx = await setupTrade();

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        gamingItemTrade.registerItem(
          tx.oldItemHash, 999, 999,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Note already exists");
    });
  });

  describe("Events", function () {
    it("should emit ItemRegistered event", async function () {
      const tx = await setupTrade();

      await expect(
        gamingItemTrade.registerItem(
          tx.oldItemHash, tx.gameId, tx.itemId,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(gamingItemTrade, "ItemRegistered");
    });

    it("should emit ItemTraded event on trade", async function () {
      const tx = await setupTrade();

      await gamingItemTrade.registerItem(
        tx.oldItemHash, tx.gameId, tx.itemId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        gamingItemTrade.tradeItem(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.oldItemHash, tx.newItemHash, tx.paymentNoteHash,
          tx.gameId, tx.nullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(gamingItemTrade, "ItemTraded");
    });
  });
});
