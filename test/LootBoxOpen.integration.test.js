/**
 * Integration tests for F4: Loot Box Open
 *
 * Full pipeline: ZK proof generation → on-chain verification
 * Uses the real Solidity verifier generated by snarkjs (not mock).
 */

const { expect } = require("chai");
const { ethers } = require("hardhat");
const snarkjs = require("snarkjs");
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const {
  poseidonHash,
  randomSecretKey,
  getPublicKey,
  init: initBabyJub,
} = require("../scripts/lib/circomlibBabyJub");

const CIRCUIT_NAME = "loot_box_open";
const BUILD_DIR = path.join(__dirname, "../circuits/build", CIRCUIT_NAME);
const WASM_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}_js`, `${CIRCUIT_NAME}.wasm`);
const ZKEY_PATH = path.join(BUILD_DIR, `${CIRCUIT_NAME}.zkey`);

// Default thresholds: 1% legendary, 4% epic, 15% rare, 80% common
const DEFAULT_THRESHOLDS = [100n, 500n, 2000n, 10000n];

function checkBuildFiles() {
  return fs.existsSync(ZKEY_PATH) && fs.existsSync(WASM_PATH);
}

function formatProofForSolidity(proof) {
  return {
    a: [proof.pi_a[0], proof.pi_a[1]],
    b: [
      [proof.pi_b[0][1], proof.pi_b[0][0]],
      [proof.pi_b[1][1], proof.pi_b[1][0]],
    ],
    c: [proof.pi_c[0], proof.pi_c[1]],
  };
}

function computeVrfMod(vrfOutput) {
  const randomVal = vrfOutput & 0x3FFFn;
  if (randomVal < 10000n) return randomVal;
  return randomVal - 10000n;
}

function determineRarity(vrfMod, thresholds) {
  for (let i = 0; i < thresholds.length; i++) {
    if (vrfMod < thresholds[i]) return i;
  }
  return thresholds.length - 1;
}

let _boxIdCounter = 0;

/**
 * Generate everything needed for a valid box open
 */
async function setupBoxOpen(options = {}) {
  const ownerSk = options.ownerSk || await randomSecretKey();
  const ownerPk = await getPublicKey(ownerSk);

  _boxIdCounter++;
  const boxId = options.boxId || BigInt(_boxIdCounter);
  const boxType = options.boxType || BigInt(1);
  const boxSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const itemSalt = BigInt("0x" + crypto.randomBytes(31).toString("hex"));
  const thresholds = options.thresholds || DEFAULT_THRESHOLDS;

  // Compute box commitment
  const boxCommitment = await poseidonHash([
    ownerPk.x, ownerPk.y, boxId, boxType, boxSalt,
  ]);

  // Compute nullifier
  const nullifier = await poseidonHash([boxId, boxSalt, ownerSk]);

  // Compute VRF output
  const vrfOutput = await poseidonHash([ownerSk, nullifier]);

  // Determine rarity
  const vrfMod = computeVrfMod(vrfOutput);
  const itemRarity = BigInt(determineRarity(vrfMod, thresholds));

  // Item based on rarity
  const itemId = options.itemId || BigInt(1001 + Number(itemRarity));

  // Compute outcome commitment
  const outcomeCommitment = await poseidonHash([
    ownerPk.x, ownerPk.y, itemId, itemRarity, itemSalt,
  ]);

  const circuitInputs = {
    boxCommitment: boxCommitment.toString(),
    outcomeCommitment: outcomeCommitment.toString(),
    vrfOutput: vrfOutput.toString(),
    boxId: boxId.toString(),
    nullifier: nullifier.toString(),
    ownerPkX: ownerPk.x.toString(),
    ownerPkY: ownerPk.y.toString(),
    ownerSk: ownerSk.toString(),
    boxSalt: boxSalt.toString(),
    boxType: boxType.toString(),
    itemId: itemId.toString(),
    itemRarity: itemRarity.toString(),
    itemSalt: itemSalt.toString(),
    rarityThresholds: thresholds.map(t => t.toString()),
  };

  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    circuitInputs, WASM_PATH, ZKEY_PATH
  );

  const formattedProof = formatProofForSolidity(proof);

  return {
    circuitInputs,
    proof: formattedProof,
    publicSignals,
    boxCommitment: "0x" + boxCommitment.toString(16).padStart(64, "0"),
    outcomeCommitment: "0x" + outcomeCommitment.toString(16).padStart(64, "0"),
    vrfOutput,
    boxId,
    nullifier: "0x" + nullifier.toString(16).padStart(64, "0"),
    ownerSk,
    itemRarity,
  };
}

describe("F4: Loot Box Open - Integration", function () {
  this.timeout(300000);

  let lootBoxOpen;
  let mockToken;
  let hasBuild;
  const BOX_PRICE = ethers.parseEther("10");

  before(async function () {
    await initBabyJub();
    hasBuild = checkBuildFiles();
    if (!hasBuild) {
      console.log("\n  ⚠️  Skipping integration tests: circuit not fully compiled");
      console.log("     Run: node scripts/compile-circuit.js loot_box_open\n");
      this.skip();
    }

    const verifierPath = path.join(__dirname, "../contracts/verifiers/LootBoxOpenVerifier.sol");
    if (!fs.existsSync(verifierPath)) {
      console.log("\n  ⚠️  Skipping: Solidity verifier not generated yet");
      this.skip();
    }
  });

  beforeEach(async function () {
    if (!hasBuild) this.skip();

    const [deployer] = await ethers.getSigners();

    // Deploy MockERC20
    const MockERC20 = await ethers.getContractFactory("MockERC20");
    mockToken = await MockERC20.deploy();
    await mockToken.mint(deployer.address, ethers.parseEther("100000"));

    let verifierAddress;
    try {
      const Verifier = await ethers.getContractFactory("contracts/verifiers/LootBoxOpenVerifier.sol:Groth16Verifier");
      const verifier = await Verifier.deploy();
      verifierAddress = await verifier.getAddress();
    } catch (e) {
      const MockVerifier = await ethers.getContractFactory("MockLootBoxVerifier");
      const mockVerifier = await MockVerifier.deploy();
      verifierAddress = await mockVerifier.getAddress();
    }

    const LootBoxOpen = await ethers.getContractFactory("LootBoxOpen");
    lootBoxOpen = await LootBoxOpen.deploy(verifierAddress, await mockToken.getAddress(), BOX_PRICE);

    // Pre-approve a large amount for convenience
    await mockToken.approve(await lootBoxOpen.getAddress(), ethers.parseEther("100000"));
  });

  describe("Full pipeline: proof generation → on-chain verification", function () {
    it("should register and open box with real ZK proof", async function () {
      const mintTx = await lootBoxOpen.mintBox(1);
      await mintTx.wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("encrypted")
      );

      expect(await lootBoxOpen.getNoteState(tx.boxCommitment)).to.equal(1);

      await lootBoxOpen.openBox(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.boxCommitment, tx.outcomeCommitment,
        tx.vrfOutput, tx.boxId, tx.nullifier,
        ethers.toUtf8Bytes("outcome-encrypted")
      );

      expect(await lootBoxOpen.getNoteState(tx.boxCommitment)).to.equal(2);
      expect(await lootBoxOpen.getNoteState(tx.outcomeCommitment)).to.equal(1);
      expect(await lootBoxOpen.isNullifierUsed(tx.nullifier)).to.be.true;
    });

    it("should open box with different box type", async function () {
      const mintTx = await lootBoxOpen.mintBox(3);
      await mintTx.wait();
      const tx = await setupBoxOpen({ boxId: 1n, boxType: BigInt(3) });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("encrypted")
      );

      await lootBoxOpen.openBox(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.boxCommitment, tx.outcomeCommitment,
        tx.vrfOutput, tx.boxId, tx.nullifier,
        ethers.toUtf8Bytes("outcome-encrypted")
      );

      expect(await lootBoxOpen.getNoteState(tx.boxCommitment)).to.equal(2);
      expect(await lootBoxOpen.getNoteState(tx.outcomeCommitment)).to.equal(1);
    });

    it("should open multiple boxes from same owner", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      await (await lootBoxOpen.mintBox(0)).wait();

      const ownerSk = await randomSecretKey();
      const tx1 = await setupBoxOpen({ ownerSk, boxId: 1n });
      const tx2 = await setupBoxOpen({ ownerSk, boxId: 2n });

      await lootBoxOpen.registerBox(
        tx1.boxCommitment, tx1.boxId,
        ethers.toUtf8Bytes("enc1")
      );
      await lootBoxOpen.registerBox(
        tx2.boxCommitment, tx2.boxId,
        ethers.toUtf8Bytes("enc2")
      );

      await lootBoxOpen.openBox(
        tx1.proof.a, tx1.proof.b, tx1.proof.c,
        tx1.boxCommitment, tx1.outcomeCommitment,
        tx1.vrfOutput, tx1.boxId, tx1.nullifier,
        ethers.toUtf8Bytes("out1")
      );

      await lootBoxOpen.openBox(
        tx2.proof.a, tx2.proof.b, tx2.proof.c,
        tx2.boxCommitment, tx2.outcomeCommitment,
        tx2.vrfOutput, tx2.boxId, tx2.nullifier,
        ethers.toUtf8Bytes("out2")
      );

      expect(await lootBoxOpen.getNoteState(tx1.boxCommitment)).to.equal(2);
      expect(await lootBoxOpen.getNoteState(tx2.boxCommitment)).to.equal(2);
      expect(await lootBoxOpen.getNoteState(tx1.outcomeCommitment)).to.equal(1);
      expect(await lootBoxOpen.getNoteState(tx2.outcomeCommitment)).to.equal(1);
    });
  });

  describe("Security: rejection cases", function () {
    it("should reject double-open (same nullifier)", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("enc")
      );

      await lootBoxOpen.openBox(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.boxCommitment, tx.outcomeCommitment,
        tx.vrfOutput, tx.boxId, tx.nullifier,
        ethers.toUtf8Bytes("enc")
      );

      const fakeOutcome = ethers.keccak256(ethers.toUtf8Bytes("fake-outcome"));
      await expect(
        lootBoxOpen.openBox(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.outcomeCommitment, fakeOutcome,
          tx.vrfOutput, tx.boxId, tx.nullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Nullifier already used");
    });

    it("should reject opening already-spent box", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("enc")
      );

      await lootBoxOpen.openBox(
        tx.proof.a, tx.proof.b, tx.proof.c,
        tx.boxCommitment, tx.outcomeCommitment,
        tx.vrfOutput, tx.boxId, tx.nullifier,
        ethers.toUtf8Bytes("enc")
      );

      const fakeNullifier = ethers.keccak256(ethers.toUtf8Bytes("fake-null"));
      const fakeOutcome = ethers.keccak256(ethers.toUtf8Bytes("fake2"));
      await expect(
        lootBoxOpen.openBox(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.boxCommitment, fakeOutcome,
          tx.vrfOutput, tx.boxId, fakeNullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.be.revertedWith("Note does not exist or already spent");
    });

    it("should reject duplicate box registration", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("enc")
      );

      const fakeHash = ethers.keccak256(ethers.toUtf8Bytes("diff-hash"));
      await expect(
        lootBoxOpen.registerBox(fakeHash, tx.boxId, ethers.toUtf8Bytes("enc"))
      ).to.be.revertedWith("Box already registered");
    });

    it("should reject duplicate note hash registration", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        lootBoxOpen.registerBox(tx.boxCommitment, 2, ethers.toUtf8Bytes("enc"))
      ).to.be.revertedWith("Note already exists");
    });
  });

  describe("Events", function () {
    it("should emit BoxRegistered event", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await expect(
        lootBoxOpen.registerBox(
          tx.boxCommitment, tx.boxId,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(lootBoxOpen, "BoxRegistered");
    });

    it("should emit BoxOpened event on open", async function () {
      await (await lootBoxOpen.mintBox(0)).wait();
      const tx = await setupBoxOpen({ boxId: 1n });

      await lootBoxOpen.registerBox(
        tx.boxCommitment, tx.boxId,
        ethers.toUtf8Bytes("enc")
      );

      await expect(
        lootBoxOpen.openBox(
          tx.proof.a, tx.proof.b, tx.proof.c,
          tx.boxCommitment, tx.outcomeCommitment,
          tx.vrfOutput, tx.boxId, tx.nullifier,
          ethers.toUtf8Bytes("enc")
        )
      ).to.emit(lootBoxOpen, "BoxOpened");
    });
  });
});
